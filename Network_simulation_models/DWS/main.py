#!/usr/local/bin/env python
# -*- coding: utf-8 -*-

"""
#######################################
#                                     #
#-- Watts-Strogatz type moves on diamond lattice --# 
#------------  Author: Devosmita Sen  -------------#
#                                     #
#######################################

"""





from timeit import default_timer as timer
import networkx as nx
import random
import numpy as np
import param as p
from numpy import linalg as LA
##import subprocess
##from timeit import default_timer as timer


import numpy as np
import networkx as nx
from timeit import default_timer as timer   

start=timer()

G=nx.MultiGraph()
Gmult=nx.MultiGraph()
GDi=nx.DiGraph()
class node:
    def __init__(self,node_pos,node_num):
        self.pos=node_pos
        self.num=node_num

        
a=3 #  divisions on each edge
# the node with coordinnate a+1 is the same as the node with coordinate 0- for simple cubic
# for this case- anything with coordinates >=a+1 comes back to other end through 0
# this means- x=x%(a+1)
# Periodic Boundary Conditions implemented
num_unit_cells=(a+1)**3
tot_nodes=8*num_unit_cells # in each unit cell- only 14 nodes are associated with connections, rest will get repeated
print(tot_nodes*2)
##stop
nodes=[None]*tot_nodes
node_cnt=0
for x in range(0,a+1):
    x=float(x)
##    print('x',x)
    for y in range(0,a+1):
        y=float(y)
##        print('y',y)
        for z in range(0,a+1):
            z=float(z)
##            print('z',z)

            # for each corner atom, the corresponding x,y and z axes can be generated and thus the unit cell gets denerated
            # then fill out the face and internal atoms for each
            # some of the face atoms will have already been positioned in the previous unit cell, in that case, maintain a list of positions already visited
            # and add new position only if that node does not already exist
            # if only the face nodes along hkl planes 100,010,001 passing through the current node position, then no face nodes will get repeated ever
            # but if these are not included, then some connections will be missing

            # so, for the connections, these should be definitely included in each unit cell.- In order to prevent repetition/ assignment of multiple nodes at the same position- the node should be assigned only if it does not exist, but it has to be accounted for in every unit cell
            # so- assing the node as object only if has not been counted earlier, but do the connections each time
            # internal tetrahedral nodes are never common between two different unit cells

            # connections are always between a corner node and an internal tetrahedral node or a face node and an internal tetrahedral node
            # there is never a connection between a face node and a corner node or between two face nodes or between two corner nodes or between two internal tetrahedral nodes

            pos_list=nx.get_node_attributes(G,'pos')
            
                        
            pos_main=(x,y,z) # corner node: relative position is (0,0,0) # position of main node in context
            pos_main=tuple(i %(a+1) for i in pos_main)
            pos=pos_main
            pos_c=pos
            
            if(pos_c not in list(pos_list.values())):
                G.add_node(node_cnt, pos=pos)
            
##            stop
                n=node(pos_main,node_cnt)
                nodes[node_cnt]=n
                node_cnt_c=node_cnt
                node_cnt=node_cnt+1
            else:
                node_cnt_c=list(pos_list.values()).index(pos_c)
            # corresponding internal site:
            pos=(x+0.25,y+0.25,z+0.25)
            pos=tuple(i %(a+1) for i in pos)

            n=node(pos,node_cnt)
            nodes[node_cnt]=n            
            G.add_node(node_cnt, pos=pos)#(pos[0],pos[1],pos[2])

            node_cnt_tc=node_cnt # internal tetrahedral site(t) generated by centre(c)

            G.add_edge(node_cnt_tc,node_cnt_c)
            
            node_cnt=node_cnt+1

            # connections of internal site generated by current corner atom
            pos_f1=(x,y+0.5,z+0.5)
            pos_f1=tuple(i %(a+1) for i in pos_f1)
            pos=pos_f1

            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tc
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tc
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            
            pos_f2=(x+0.5,y,z+0.5)
            pos_f2=tuple(i %(a+1) for i in pos_f2)
            pos=pos_f2

            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tc
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tc
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

                


            pos_f3=(x+0.5,y+0.5,z)
            pos_f3=tuple(i %(a+1) for i in pos_f3)
            pos=pos_f3

            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tc
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tc
                node_2=node_cnt
                G.add_edge(node_1,node_2)
##                if(node_1==2):
##                    print('node_2',node_2)
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1
                

            

            
            # face nodes: ( only 3 considered because the rest will get repeated
            #1
            pos_main=pos_f1
            pos_main=tuple(i %(a+1) for i in pos_main)
            pos=pos_main
            pos_list=nx.get_node_attributes(G,'pos')
            node_cnt_f1=list(pos_list.values()).index(pos_main) 
            # already added node, hence no need to add again
                       
            # corresponding internal site:
            
            pos=tuple(map(sum, zip(pos_main, (0.25,0.25,0.25))))
            pos=tuple(i %(a+1) for i in pos)
            pos_i=pos # corresponding internal site

            n=node(pos,node_cnt)
            nodes[node_cnt]=n 
            G.add_node(node_cnt,pos=pos)
            node_cnt_tf1=node_cnt# internal tetrahedral site(t) generated by face1(f1)

            # attach to main generating node                       
            G.add_edge(node_cnt_f1,node_cnt_tf1)

            node_cnt=node_cnt+1
          

            pos=tuple(map(sum, zip(pos_i, (0,0.5,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)
            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tf1
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf1
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0.5,0,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)

            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf1
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf1
                node_2=node_cnt
                G.add_edge(node_1,node_2)
                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n

                node_cnt=node_cnt+1
            

            pos=tuple(map(sum, zip(pos_i, (0.5,0.5,0), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)

            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf1
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf1
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1
            
            #2

            pos_main=pos_f2
            pos=pos_main
            node_cnt_f2=list(pos_list.values()).index(pos_main) 
            # already added node, hence no need to add again
                       
            # corresponding internal site:
            pos=tuple(map(sum, zip(pos, (0.25,0.25,0.25))))
            pos=tuple(i %(a+1) for i in pos)
            pos_i=pos

            n=node(pos,node_cnt)
            nodes[node_cnt]=n 
            G.add_node(node_cnt,pos=pos)
            node_cnt_tf2=node_cnt# internal tetrahedral site(t) generated by face2(f2)

            # attach to main generating node                       
            G.add_edge(node_cnt_f2,node_cnt_tf2)

            node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0,0.5,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)
            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tf2
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf2
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0.5,0,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)

            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf2
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf2
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0.5,0.5,0), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)

            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf2
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf2
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1
            
            #3


            pos_main=pos_f3
            pos=pos_main
            node_cnt_f3=list(pos_list.values()).index(pos_main) 
            # already added node, hence no need to add again
                       
            # corresponding internal site:
            pos=tuple(map(sum, zip(pos, (0.25,0.25,0.25))))
            pos=tuple(i %(a+1) for i in pos)
            pos_i=pos

            n=node(pos,node_cnt)
            nodes[node_cnt]=n 
            G.add_node(node_cnt,pos=pos)
            node_cnt_tf3=node_cnt# internal tetrahedral site(t) generated by face1(f1)

            # attach to main generating node                       
            G.add_edge(node_cnt_f3,node_cnt_tf3)

            node_cnt=node_cnt+1
          

            pos=tuple(map(sum, zip(pos_i, (0,0.5,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)            
            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # tmp- can be corner or face
                node_1=node_cnt_tf3
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf3
                node_2=node_cnt
                G.add_edge(node_1,node_2)

                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0.5,0,0.5), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)

            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf3
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)

            except(ValueError):

                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf3
                node_2=node_cnt
                G.add_edge(node_1,node_2)
                
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1

            pos=tuple(map(sum, zip(pos_i, (0.5,0.5,0), (-0.25,-0.25,-0.25))))#tuple(i * 2 for i in pos_main) # tmp
            pos=tuple(i %(a+1) for i in pos)
            pos_list=nx.get_node_attributes(G,'pos')
            try:
                node_cnt_tmp=list(pos_list.values()).index(pos) # corner
                node_1=node_cnt_tf3
                node_2=node_cnt_tmp
                G.add_edge(node_1,node_2)
            except(ValueError):
                G.add_node(node_cnt, pos=pos)
                node_1=node_cnt_tf3
                node_2=node_cnt
                G.add_edge(node_1,node_2)
                n=node(pos,node_cnt)
                nodes[node_cnt]=n
                node_cnt=node_cnt+1
            

print('all_done')

one=0
two=0
three=0
four=0
five=0
six=0
for i in G:
    if((G.degree(i))==1):
        one=one+1
    if((G.degree(i))==2):
        two=two+1
    if((G.degree(i))==3):
        three=three+1
    if((G.degree(i))==4):
        four=four+1
    if((G.degree(i))==5):
        five=five+1
    if((G.degree(i))==6):
        six=six+1

print('G:')
print('Number of nodes:',len(G))
print('Number of edges',len(G.edges))
print('one',one)
print('two',two)
print('three',three)
print('four',four)
print('five',five)
print('six',six)


end=timer()

print('Total time taken for diamond lattice generation=',end-start)


def dist(n1,n2, Lx, Ly, Lz):
    dx=n1[0]-n2[0]
    dy=n1[1]-n2[1]
    dz=n1[2]-n2[2]

    ##PERIODIC BOUNDARY CONDITION TO BE IMPLEMENTED!!!
    
    dx = dx - int(round(dx/Lx))*Lx
    dy = dy - int(round(dy/Ly))*Ly
    dz = dz - int(round(dz/Lz))*Lz
    
    d=[dx,dy,dz]
    dist = LA.norm(d)

    return dist



random.seed(a=None,version=2)

##start=timer()

##cR3=10
##conc=cR3/(N*b**2)**1.5 #(chains/nm3)


############################
# uptil now, the network has been generated assuming lattice parameter as 1, and the positions have been assigned accordingly
# there was no concept of physical 'length' until now
# but now- we want to put in a physical length according to the concentration
# so, the entire length of the box will be L instead of (a+1)
# this value of L will be obtained based on the concentration and number fo chains in the system
N=p.N
b=p.b

d=N*b/4# contour length
n_chains=len(G.edges)

cR3=p.cR3
conc=cR3/(N*b**2)**1.5 #(chains/nm3)
n_chains=len(G.edges)
L=(n_chains/conc)**(1/3)
c_mM=conc/0.6022 # conc in mM
print('conc',conc)
print('c_mM',c_mM)
print('cR3',cR3)
pos_list_dict=nx.get_node_attributes(G,'pos')
pos=[list(x) for x in list(pos_list_dict.values())]
##stop
pos=np.array(pos)*(L/(a+1)) # scale the positions to the new dimensions


# completely random edge swap
tot_swaps=n_chains
wrt_step=int(tot_swaps/50)
num_swaps=0 # total number of swaps done till now

print(' len(G.edges)', len(G.edges))

print('num_swaps',num_swaps)
np.savetxt('network.txt',np.array(list(G.edges())),delimiter=',',header='Node1,Node2')
##subprocess.run(['python', 'count_cycles.py',str(num_swaps)])
##stop
##input("Press any key to continue the program")
start=timer()
while(num_swaps<tot_swaps):
    updated=False

    edge_list=list(G.edges)

    edge_idx_1=random.randint(0,len(edge_list)-1)
    n1_e1=edge_list[edge_idx_1][0] # node 1 of edge 1
    n2_e1=edge_list[edge_idx_1][1] # node 2 of edge 1

    edge_idx_2=random.randint(0,len(edge_list)-1)
    while(edge_idx_2==edge_idx_1):
        edge_idx_2=random.randint(0,len(edge_list)-1)
    n1_e2=edge_list[edge_idx_2][0] # node 1 of edge 2
    n2_e2=edge_list[edge_idx_2][1] # node 2 of edge 2

    # potential new edge between 1. (n1_e1-n2e2,n1e2-n2e1) or 2. (n1_e1-n1e2,n2_e1-n2_e2)

    # IMPORTANT!!-length L to be modified later!!!
    r1_1=dist(pos[n1_e1],pos[n2_e2],L,L,L)
    r1_2=dist(pos[n1_e2],pos[n2_e1],L,L,L)
    
    r2_1=dist(pos[n1_e1],pos[n1_e2],L,L,L)
    r2_2=dist(pos[n2_e1],pos[n2_e2],L,L,L)
    
    if(r1_1<=d and r1_2<=d):
        n_chains=len(G.edges)
        G.remove_edges_from([(n1_e1,n2_e1),(n1_e2,n2_e2)])
        G.add_edges_from([(n1_e1,n2_e2),(n1_e2,n2_e1)])
        
        num_swaps=num_swaps+1
        updated=True
    elif(r2_1<=d and r2_2<=d):
        G.remove_edges_from([(n1_e1,n2_e1),(n1_e2,n2_e2)])
        G.add_edges_from([(n1_e1,n1_e2),(n2_e1,n2_e2)])
        num_swaps=num_swaps+1
        updated=True
    if((num_swaps)%wrt_step==0 and updated==True):
        print('num_swaps',num_swaps,' len(G.edges)', len(G.edges))
        np.savetxt('network'+str(num_swaps)+'.txt',np.array(list(G.edges())),delimiter=',',header='Node1,Node2')
##        subprocess.run(['python', 'count_cycles.py',str(num_swaps)])
##        input("Press any key to continue the program")


end=timer()
print('Swap_time=', end-start)

